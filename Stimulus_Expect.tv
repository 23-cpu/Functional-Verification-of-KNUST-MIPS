00221820 00000014 00000004 00000000 0  -- add $3, $1, $2     => 5 + 15 = 20
00221822 00000004 00000008 00000000 0  -- sub $3, $1, $2     => 15 - 11 = 4
00221824 00000001 0000000C 00000000 0  -- and $3, $1, $2     => 1 & 3 = 1
00221825 0000001F 00000010 00000000 0  -- or  $3, $1, $2     => 1 | 30 = 31
0022182A 00000001 00000014 00000000 0  -- slt $3, $1, $2     => 1 < 3 => 1
00021880 00000008 00000018 00000000 0  -- sll $3, $2, 2      => 2 << 2 = 8
00021882 00000001 0000001C 00000000 0  -- srl $3, $2, 2      => 4 >> 2 = 1
00221826 00000006 00000020 00000000 0  -- xor $3, $1, $2     => 5 ^ 3 = 6
00200008 00000000 00000028 00000000 0  -- jr $1              => jump to $1, PC = $1
20220005 00000005 0000002C 00000000 0  -- addi $2, $1, 5     => $2 = $1 + 5
8C220004 00000000 00000030 00000000 0  -- lw $2, 4($1)       => load mem[$1 + 4]
AC220008 00000000 00000034 00000007 1  -- sw $2, 8($1)       => store $2 at mem[$1 + 8]
10430003 00000000 00000038 00000000 0  -- beq $2, $3, +3     => branch if equal
0800000A 00000000 00000040 00000000 0  -- j 0xA              => jump to PC=0x28
0C00000B 00000000 00000044 00000000 0  -- jal 0xB            => $ra = PC+4, PC = 0x2C
FFFFFFFF 00000000 00000048 00000000 0  -- halt              => special halt code
